---
description: Implementation step requirements for incremental development
globs: **/*.{ts,tsx,js,jsx}
---

# Implementation Step Requirements

## Rule: End-User-Testable Steps

Each implementation step MUST be:
- **End-user-testable**: Can be manually tested by a user in the browser/app
- **Fully debuggable**: Can be debugged with standard tools (browser devtools, server logs)
- **Perfected**: Complete, working, and polished (not half-baked)
- **Time-bound**: Achievable within **one hour of effort**

## Process

1. **Plan the Step**: Identify the smallest end-user-testable increment
2. **Environment Variables**: When using `NEXT_PUBLIC_*` variables:
   - Access directly: `process.env.NEXT_PUBLIC_MY_VAR` (not through helper functions)
   - Use try-catch pattern for safe access
   - Verify in browser console after restarting dev server
   - Document in `.env.local.example` if public-facing
3. **Add Diagnostic Logging**: Before implementing, add structured logging at each critical step to isolate failures:
   - Log inputs (what data is received)
   - Log transformations (what data is processed)
   - Log outputs (what data is returned/saved)
   - Use consistent log keys (e.g., `profile_update_request`, `profile_update_db_save`)
   - Log both server-side (`logger.info`) and client-side (`console.log` with `[component]` prefix)
   - Log critical fields with their types to catch serialization issues
3. **Implement**: Build the complete feature for that step. Name code that is self-documenting. Do not add comments to code.
4. **Test**: Manually test as an end-user would
5. **Debug**: Fix any issues until it works perfectly (use logs to isolate the first failing step)
6. **Verify**: Confirm it's debuggable and testable. Disable diagnostic logging when diagnosing.
7. **Document**: Create or update test documentation (see Domain Documentation Driven Development)
8. **Commit**: Only commit when the step is complete and working. Delete unused files.
9. **Prevention**: After fixing a bug, update Cursor rules to prevent similar high-risk issues in the future. Keep rules brief and actionable.

## Domain Documentation Driven Development

### Requirements

- **Public-Facing**: Documentation must be accessible to anyone with the git repo
- **Reproducible**: Steps must allow anyone to verify the feature works
- **Brief**: Keep instructions concise and actionable and under 400 words per doc
- **Fast Verification**: Each feature should be manually-verifiable within **60 seconds**
- **Quality Verification**: Include verification features when needed:
  - **Preferred**: Integrated into end-user experience
  - **Fallback**: Safe verification mode for end-users
  - **Constraints**: Maintain security, stability, and performance
- **Organization**: Store testing in a section of the **same** tech spec document in `docs/specs`.
- **Linking**: Link from README.md
- **Format**: Markdown only with Mermaid diagrams (GitHub/GitLab compatible)
- **Completion**: When a step is complete, mention the documentation file path

### Documentation Structure

Each feature test document should include:
1. **Quick Start** (30 seconds): Fastest path to verify
2. **Prerequisites**: Required setup/environment
3. **Test Steps**: Step-by-step manual testing instructions
4. **Expected Results**: What should happen
5. **Architecture Diagram**: Mermaid diagram showing the feature flow
6. **Troubleshooting**: Common issues and solutions

## Examples

### ✅ Good: End-User-Testable Step
- "User can see their session appear in admin sessions list after navigating"
- Testable: Navigate → Check admin page → See session
- Debuggable: Check browser console, server logs, database
- Time: ~1 hour
- Documentation: `docs/testing/session-replay-route-recording.md`

### ❌ Bad: Not End-User-Testable
- "Add encoding utilities" (no user-visible change)
- "Create database schema" (no user-visible change)
- "Set up test infrastructure" (no user-visible change)

## Benefits

- **Fast Feedback**: See results immediately
- **Early Validation**: Confirm approach works before building more
- **Easier Debugging**: Smaller scope = easier to debug
- **User Value**: Each step delivers visible value
- **Momentum**: Quick wins keep development moving
- **Documentation**: Living documentation that stays current with implementation
